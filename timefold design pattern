这份文档是 Timefold 的架构设计模式指南。它不教你具体的 API 怎么写，而是教你针对不同的业务痛点，该如何构建数据模型和算法逻辑。

对于 CDMO 这种逻辑极度琐碎、涉及物理化学规则的行业，这些模式是决定系统“能用”和“好用”的分水岭。以下是核心内容的详细解释：

1. 时间建模模式 (Time Modeling)

文档讨论了两种处理时间的方式：

时间片模式 (Time Grain Pattern)：

原理：将时间切成固定大小的“格子”（如每 15 分钟一格）。

CDMO 场景：适合所有任务时长都是固定倍数的情况。但制药中反应时长各异（3.5小时、42分钟），这种模式会导致严重的产能浪费或过于庞大的计算量。

连续时间模式 (Continuous Time Pattern) —— 【CDMO 推荐】：

原理：开始时间是一个精确的 LocalDateTime 变量。

优势：配合影子变量 (Shadow Variables)，可以精确计算“反应结束时间 = 开始时间 + 工艺耗时”。这在 CDMO 中至关重要，因为你需要压榨反应釜的每一分钟周转。

2. 任务分配 vs 路径规划模式 (Assigning Patterns)

这决定了你如何理解“反应釜”和“批次”的关系：

任务分配 (Task Assigning)：

关注点：谁有空？谁能做？（强调设备兼容性）。

车辆路径 (VRP - Vehicle Routing)：

关注点：从 A 到 B 的切换成本是多少？（强调清洗代价）。

【综合应用】：CDMO 实际上是这两者的结合。文档建议使用 Planning List Variable。

把反应釜看作车辆，把批次看作停靠点。

List Variable 模式：每个反应釜拥有一个 List<Batch>，列表的顺序即生产顺序。这是目前处理设备切换（清洗成本）最先进的模式。

3. 影子变量模式 (Shadow Variables) —— 【系统的灵魂】

这是文档中技术含量最高的一环，也是解决 CDMO 业务逻辑的核心工具。

模式内容：你只让求解器决定“顺序”，剩下的所有属性（如：开始时间、结束时间、清洗耗时）都通过代码自动推导。

CDMO 应用场景：

CIP/SIP (清洗) 自动计算：如果上个批次是药 A，当前是药 B，影子变量会自动查询清洗矩阵，计算出需要 4 小时的清洗。

时间链式反应：一旦 Solver 交换了两个批次的顺序，影子变量会像多米诺骨牌一样，自动更新后续所有批次的开始和结束时间。

4. 超限规划模式 (Overconstrained Planning)

当你的订单量远超工厂产能（反应釜塞不下了）时，系统该怎么办？

模式建议：

虚拟资源：给 Solver 一个“虚拟反应釜”，所有排不下的任务都扔进去，但要收极高的“罚金”（惩罚分数）。

可为空变量 (Nullable Variables)：允许任务不分配。

价值：它能让系统在产能不足时，自动挑选出利润最高或优先级最高的订单，并告诉你哪些订单必须推迟。

5. 多阶段规划 (Multi-stage Planning)

如果你的厂区极大（几千个批次同时排），直接算会很慢。

分层策略：

第一阶段（大排产）：决定哪些订单分配给哪个车间（月度计划）。

第二阶段（精排产）：在车间内分配具体的反应釜和顺序（周/日计划）。

价值：通过降维打击，解决超大规模优化问题。

6. 多实体资源约束 (Multi-resource Constraints)

CDMO 不仅仅需要反应釜。

模式内容：一个任务需要同时满足多个资源。

例子：生产一个批次需要：反应釜 A + 操作班组 B + 专用温控模组 C。

实现：文档建议通过实体的嵌套引用或多个 Planning Variable 来实现协同调度。

7. 针对 CDMO 的设计建议（基于此文档）：

别用“格子”排时间：用 Planning List Variable 处理反应釜的任务清单。

把清洗逻辑写在影子变量里：不要作为硬约束去“撞”，要作为随动计算去“导”。

支持“插单/删单”：利用 Overconstrained Planning 模式，防止在需求爆炸时系统给出“不可解”的报错。

建立“清洗矩阵”事实：将不同药品间的清洗时间作为 Problem Fact 存入 Solution。

总结：
这一页文档告诉你：不要试图把所有逻辑都压在求解器身上，要通过巧妙的模型设计（特别是 List Variable 和 Shadow Variable），让求解器只需要处理简单的“排序”动作，而复杂的物理规则通过业务逻辑自动推导。
