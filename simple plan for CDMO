import com.google.ortools.Loader;
import com.google.ortools.sat.*;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.stream.IntStream;

/**
 * 制药 CDMO 反应釜排产简单示例
 */
public class CdmoScheduling {

    // 模拟数据结构
    static class Task {
        int jobId;
        int taskId;
        int duration;
        List<Integer> compatibleVessels; // 该任务可以使用的反应釜ID

        Task(int j, int t, int d, List<Integer> v) {
            this.jobId = j;
            this.taskId = t;
            this.duration = d;
            this.compatibleVessels = v;
        }
    }

    public static void main(String[] args) {
        Loader.loadNativeLibraries();

        // 1. 定义数据
        // 假设有 3 个 Job (订单)，每个 Job 有 2 个工序
        // 假设有 3 个反应釜 (Vessel 0, 1, 2)
        int numVessels = 3;
        List<List<Task>> jobs = new ArrayList<>();
        
        // Job 0: 工序0(5h, 釜0或1) -> 工序1(3h, 釜1或2)
        jobs.add(Arrays.asList(
            new Task(0, 0, 5, Arrays.asList(0, 1)),
            new Task(0, 1, 3, Arrays.asList(1, 2))
        ));

        // Job 1: 工序0(4h, 釜0或2) -> 工序1(6h, 釜0或1或2)
        jobs.add(Arrays.asList(
            new Task(1, 0, 4, Arrays.asList(0, 2)),
            new Task(1, 1, 6, Arrays.asList(0, 1, 2))
        ));

        // Job 2: 工序0(3h, 釜1) -> 工序1(4h, 釜2)
        jobs.add(Arrays.asList(
            new Task(2, 0, 3, Arrays.asList(1)),
            new Task(2, 1, 4, Arrays.asList(2))
        ));

        CpModel model = new CpModel();

        // 预测一个最大时间上限 (Horizon)
        int horizon = 100;

        // 2. 变量定义
        // 每个任务在特定釜上的执行情况
        // taskIntervals[job_id][task_id]
        // vesselIntervals[vessel_id] 存储分配到该釜的所有任务
        List<IntervalVar>[] vesselIntervals = new List[numVessels];
        for (int v = 0; v < numVessels; v++) vesselIntervals[v] = new ArrayList<>();

        IntVar makespan = model.newIntVar(0, horizon, "makespan");
        
        // 存储每个任务的最终开始/结束变量，用于后续约束和输出
        class TaskVars {
            IntVar start;
            IntVar end;
            List<PresenceTask> presences = new ArrayList<>();
        }
        class PresenceTask {
            int vesselId;
            OptionalIntervalVar interval;
            Literal presence;
        }

        TaskVars[][] allTaskVars = new TaskVars[jobs.size()][];

        for (int j = 0; j < jobs.size(); j++) {
            allTaskVars[j] = new TaskVars[jobs.get(j).size()];
            for (int t = 0; t < jobs.get(j).size(); t++) {
                Task task = jobs.get(j).get(t);
                TaskVars tv = new TaskVars();
                tv.start = model.newIntVar(0, horizon, "j" + j + "t" + t + "_start");
                tv.end = model.newIntVar(0, horizon, "j" + j + "t" + t + "_end");
                
                // 任务在不同可选釜上的表现
                List<Literal> presenceLiterals = new ArrayList<>();
                for (int vId : task.compatibleVessels) {
                    Literal presence = model.newBoolVar("j" + j + "t" + t + "_v" + vId);
                    OptionalIntervalVar interval = model.newOptionalIntervalVar(
                        tv.start, model.newConstant(task.duration), tv.end, presence, "interval_j" + j + "t" + t + "_v" + vId
                    );
                    
                    PresenceTask pt = new PresenceTask();
                    pt.vesselId = vId;
                    pt.interval = interval;
                    pt.presence = presence;
                    
                    tv.presences.add(pt);
                    presenceLiterals.add(presence);
                    vesselIntervals[vId].add(interval);
                }
                
                // 约束：每个任务必须且只能在一个反应釜上运行
                model.addExactlyOne(presenceLiterals.toArray(new Literal[0]));
                allTaskVars[j][t] = tv;
            }
        }

        // 3. 添加约束
        // (1) 工序先后顺序约束 (Precedence)
        for (int j = 0; j < jobs.size(); j++) {
            for (int t = 0; t < jobs.get(j).size() - 1; t++) {
                // 下一个任务的开始时间 >= 上一个任务的结束时间
                model.addGreaterOrEqual(allTaskVars[j][t+1].start, allTaskVars[j][t].end);
            }
        }

        // (2) 资源互斥约束 (No Overlap on Vessels)
        // 同一个反应釜在同一时间只能处理一个任务
        for (int v = 0; v < numVessels; v++) {
            model.addNoOverlap(vesselIntervals[v]);
        }

        // (3) 目标函数：最小化 Makespan
        for (int j = 0; j < jobs.size(); j++) {
            int lastTaskIdx = jobs.get(j).size() - 1;
            model.addLessOrEqual(allTaskVars[j][lastTaskIdx].end, makespan);
        }
        model.minimize(makespan);

        // 4. 求解
        CpSolver solver = new CpSolver();
        // 设置求解限制时间
        solver.getParameters().setMaxTimeInSeconds(30.0);
        CpSolverStatus status = solver.solve(model);

        // 5. 输出结果
        if (status == CpSolverStatus.OPTIMAL || status == CpSolverStatus.FEASIBLE) {
            System.out.println("最优总完工时间 (Makespan): " + solver.value(makespan));
            for (int j = 0; j < jobs.size(); j++) {
                for (int t = 0; t < jobs.get(j).size(); t++) {
                    TaskVars tv = allTaskVars[j][t];
                    long start = solver.value(tv.start);
                    long end = solver.value(tv.end);
                    int vesselUsed = -1;
                    for(PresenceTask pt : tv.presences) {
                        if (solver.booleanValue(pt.presence)) {
                            vesselUsed = pt.vesselId;
                            break;
                        }
                    }
                    System.out.printf("订单 %d - 工序 %d: 反应釜 R%d | 开始: %d, 结束: %d, 持续: %d\n", 
                        j, t, vesselUsed, start, end, (end - start));
                }
            }
        } else {
            System.out.println("未找到可行解。");
        }
    }
}
