Planning List Variable 是 Timefold 近两年推出的“杀手锏”级特性。它彻底改变了处理**“顺序”和“分配”**问题的建模方式。

在传统的建模中，我们要搞定“哪个反应釜做哪个药，且按什么顺序做”非常痛苦。而 List Variable 让这一切变得极其直观。

1. 核心定义：什么是 List Variable？

想象你是一个工厂调度员，你面前有 3 个反应釜（Reactor），手里有 10 个生产任务（Batch）。

传统做法：你需要给每个任务标上“我是哪个釜”和“我是第几个”。

List Variable 做法：每个反应釜直接拥有一个 List<Batch>。

你只需要把任务像“塞卡片”一样塞进某个反应釜的 List 里。List 中元素的索引（Index）就代表了生产的先后顺序。

2. 为什么它对 CDMO 特别重要？（对比 VRP 和任务分配）

在 CDMO 场景中，反应釜排程本质上是一个 多设备任务分配与排序问题，这与 VRP（车辆路径规划）高度相似：

VRP（车辆路径）：一台车（反应釜）跑多个点（任务），顺序决定了路程（清洗切换耗时）。

Task Assigning（任务分配）：一个工人（反应釜）处理一串工单（任务），顺序决定了完工时间。

List Variable 的威力在于：它同时解决了“分给谁”和“按什么顺序”这两个问题。

3. 代码如何实现？（CDMO 例子）
第一步：定义 Planning Value（被排的对象）

这是被放进 List 里的元素。

code
Java
download
content_copy
expand_less
public class BatchJob {
    private String id;
    private int durationMinutes; // 反应时长
    // 注意：这里不需要加 @PlanningVariable
}
第二步：定义 Planning Entity（持有 List 的容器）

这是“反应釜”，它是排程的主体。

code
Java
download
content_copy
expand_less
@PlanningEntity
public class Reactor {
    private String name;

    // 核心：定义 List 变量
    @PlanningListVariable(valueRangeProviderRefs = "batchRange")
    private List<BatchJob> batchList = new ArrayList<>();
    
    // ...
}
第三步：定义 Planning Solution（全局容器）
code
Java
download
content_copy
expand_less
@PlanningSolution
public class ProductionSchedule {
    @ValueRangeProvider(id = "batchRange")
    @PlanningEntityCollectionProperty
    private List<BatchJob> allBatches; // 所有待排的任务

    @PlanningEntityCollectionProperty
    private List<Reactor> allReactors; // 所有反应釜
    
    // ...
}
4. 它是如何运作的？（Solver 的动作）

当 Solver 运行时，它会执行以下三种极其高效的操作：

Move：把一个 BatchJob 从反应釜 A 的 List 移到反应釜 B。

Swap：交换反应釜 A 里的两个任务，或者交换 A 和 B 之间的任务。

Shuffle：在同一个反应釜的 List 内部重新排序。

5. 杀手锏功能：影子变量（Shadow Variables）

在 CDMO 中，最重要的计算是：“Batch B 什么时候开始？”
答案是：Batch A 的结束时间 + 反应釜切换/清洗耗时。

List Variable 配合 @InverseRelationShadowVariable 和 @NextElementShadowVariable，可以让你在代码里写出极其优雅的逻辑：

code
Java
download
content_copy
expand_less
public class BatchJob {
    // 影子变量：自动知道自己属于哪个反应釜
    @InverseRelationShadowVariable(sourceVariableName = "batchList")
    private Reactor reactor;

    // 影子变量：自动知道自己前一个任务是谁
    @PreviousElementShadowVariable(sourceVariableName = "batchList")
    private BatchJob previousBatch;

    // 这样你就能轻松计算：
    public LocalDateTime getStartTime() {
        if (previousBatch == null) {
            return reactor.getReadyTime(); // 反应釜空闲时间
        }
        return previousBatch.getEndTime().plusMinutes(calculateCleaningTime(previousBatch, this));
    }
}
6. List Variable 的优势（为什么你应该用它？）

直观性：它完美对应了现实世界——反应釜的任务清单。

性能极高：Timefold 针对 List 结构的移动（Move）做了深度优化，比起传统的“链式建模（Chained Variable）”，它的计算速度更快，且不容易产生“无效解”。

处理“空闲”非常容易：如果一个任务没被放进任何 Reactor 的 List，它就自动处于“未分配”状态。

约束编写简单：你可以直接用 Java Stream 处理 List。比如：reactor.getBatchList().size() > 5（任务太多）。

7. 总结：何时该用 List Variable？

如果你的 CDMO 系统满足以下两个条件，请务必使用 List Variable：

资源是有限的（反应釜、离心机、工人）。

顺序很重要（先做药 A 再做药 B，和先做 B 再做 A 的清洗成本不一样）。

这目前是 Timefold 处理此类问题的官方推荐方式。它避开了传统运筹优化中复杂的索引计算，让你用写业务逻辑的方式搞定复杂的排产。

在 Timefold 的建模世界里，Planning Value（规划值） 和 Planning Value Range（值范围） 决定了 Solver（求解器）“能把什么东西填进空格里”。

如果说 Planning Variable 是填空题的“空格”，那么 Planning Value 就是“备选项”，而 Value Range 就是“备选答案的池子”。

以下是针对 CDMO 场景的详细解析：

1. Planning Value (规划值)

定义：它是 Solver 尝试分配给 @PlanningVariable 的具体对象或数值。

在 CDMO 中是什么？

如果你在排设备，Value 就是具体的 Reactor（反应釜） 实例。

如果你在排时间，Value 就是具体的 LocalDateTime 或者一个 时间片序号。

特点：

它们通常是 Problem Facts（问题事实）。

Solver 不会改变这些对象本身的属性，它只是建立变量与值之间的“引用关系”。

2. Planning Value Range (规划值范围)

定义：这是告诉 Solver：“对于这个变量，你只能从这组备选答案中挑选。”

你必须在代码中使用 @ValueRangeProvider 注解来定义这个池子。

A. 集合型范围 (Collection Value Range) —— 最常用

这是最直接的方式：直接给出一张列表。

CDMO 场景：给生产任务分配反应釜。

实现：

code
Java
download
content_copy
expand_less
@PlanningSolution
public class ProductionSchedule {
    
    // 定义答案池，起个名字叫 "reactorRange"
    @ValueRangeProvider(id = "reactorRange")
    public List<Reactor> getReactorList() {
        return reactorList;
    }

    @PlanningEntityCollectionProperty
    private List<BatchJob> batchJobList;
}

@PlanningEntity
public class BatchJob {
    // 告诉这个变量：去 "reactorRange" 找答案
    @PlanningVariable(valueRangeProviderRefs = "reactorRange")
    private Reactor reactor;
}
B. 离散型/数值型范围 (Countable Value Range)

有时答案不是对象，而是一个数字范围（如：优先级 1-10）。

实现：

code
Java
download
content_copy
expand_less
@ValueRangeProvider(id = "priorityRange")
public CountableValueRange<Integer> getPriorityRange() {
    return ValueRangeFactory.createIntValueRange(1, 11); // 1到10
}
3. 特殊但重要的 Range 类型
① 可为空的范围 (Nullable Planning Variable)

在 CDMO 中，如果任务太多，反应釜排不下，有些任务可能只能“暂不排产”。

用法：@PlanningVariable(..., nullable = true)。

效果：Solver 的备选答案中会自动多出一个 null 值。如果分配为 null，代表该任务被推迟或取消。

② 基于实体的范围 (Entity-specific Value Range) —— 制药行业核心需求

这是网页中提到的高级用法。在 CDMO 中，不是每个任务都能进每个反应釜（比如：酸性反应必须进搪瓷釜，不能进不锈钢釜）。

如果把所有反应釜都扔进全局池子，Solver 会尝试大量无效组合，效率极低。你可以让每个任务拥有自己的池子：

code
Java
download
content_copy
expand_less
@PlanningEntity
public class BatchJob {
    private List<Reactor> compatibleReactors; // 这个任务只能用的釜

    // 范围不再由 Solution 提供，而是由 Entity 自己提供
    @ValueRangeProvider(id = "localReactorRange")
    public List<Reactor> getCompatibleReactors() {
        return compatibleReactors;
    }

    @PlanningVariable(valueRangeProviderRefs = "localReactorRange")
    private Reactor reactor;
}

好处：Solver 永远不会尝试把一个强酸任务排进不锈钢釜，搜索空间大大缩小，算得极快。

4. 网页中提到的 "Value Range Providers" 注解位置

网页特别强调了注解可以放在两个地方：

放在 @PlanningSolution 上（全局）：

最通用。所有实体的变量都共用这一组答案（如：全工厂的工人）。

放在 @PlanningEntity 上（局部）：

用于处理刚才提到的“兼容性”问题。

5. 关键点总结：如何设计你的 Value Range？

在解决 CDMO 排产时，请记住以下准则：

范围越小越好：如果通过业务逻辑能确定某个任务绝对不能进某些釜，就不要把那些釜放进该任务的 Value Range。

离散化时间：如果你在排时间，不要给 Solver 一个无限细粒度的毫秒级范围。通常建议将时间“离散化”，比如以 15 分钟或 1 小时为一个颗粒（Grain），这样能指数级降低计算量。

List Variable 结合：如果你使用了上一节讲的 Planning List Variable，那么 Value Range Provider 提供的就是 List 中允许存放的所有元素（即所有的 BatchJob）。

一句话总结：Planning Value 是“答案”，Planning Value Range 是“答题范围”。好的建模应该通过缩小“答题范围”来让 Solver 更快地找到“满分答案”。


在 Timefold 的建模指南中，“Inheritance for Planning Solutions”（规划方案的继承） 探讨的是如何利用 Java 的继承机制（extends）来构建灵活、可复用的排程系统。

在 CDMO 这种业务复杂的场景下，这一特性非常有用，因为它允许你定义一个通用的基础模型，然后为不同的车间或业务场景定制具体的实现。

1. 核心概念：为什么要继承 Solution？

在一个大型制药平台中，你可能面临以下情况：

合成车间（Synthesis）：关注反应釜、温度、PH值。

制剂/包装车间（Packaging）：关注流水线速度、纸箱库存。

共同点：它们都需要定义“员工”、“排班表名称”、“总分（Score）”、“任务列表”。

如果没有继承，你得在每个车间类里重复写相同的代码。有了继承，你可以把公有逻辑抽离出来。

2. CDMO 实战建模示例

我们可以构建一个三层结构：

第一层：抽象基类 (Abstract Base Class)

这里存放所有排程场景都通用的属性。

code
Java
download
content_copy
expand_less
public abstract class AbstractCdmoSchedule {
    protected String scheduleId;

    // 所有的排程都需要保存分数
    @PlanningScore
    protected HardSoftScore score;

    // 所有的排程都需要基础员工信息
    protected List<Employee> employeeList;

    // 获取所有的任务（具体任务类型由子类决定）
    @PlanningEntityCollectionProperty
    public abstract List<? extends BaseTask> getTaskList();

    // ... getters/setters
}
第二层：具体业务实现 (Concrete Subclasses)

你可以为不同的厂区或生产模式定义具体的类。

code
Java
download
content_copy
expand_less
@PlanningSolution
public class SynthesisSchedule extends AbstractCdmoSchedule {
    
    // 合成车间特有的：反应釜事实
    @ValueRangeProvider(id = "reactorRange")
    private List<Reactor> reactorList;

    // 合成车间特有的任务类型
    private List<SynthesisTask> synthesisTaskList;

    @Override
    public List<SynthesisTask> getTaskList() {
        return synthesisTaskList;
    }
}

@PlanningSolution
public class PackagingSchedule extends AbstractCdmoSchedule {
    
    // 包装车间特有的：包装线事实
    @ValueRangeProvider(id = "lineRange")
    private List<PackagingLine> lineList;

    private List<PackagingTask> packagingTaskList;

    @Override
    public List<PackagingTask> getTaskList() {
        return packagingTaskList;
    }
}
3. 文档中提到的关键细节
A. 注解的继承性

Timefold 会自动扫描整个类继承体系。即使你在基类里标注了 @PlanningScore 或 @PlanningEntityCollectionProperty，子类依然会继承这些元数据。这意味着：

你可以在基类里统一处理分数的存储逻辑。

你可以在基类里统一管理 Solver 运行时的状态。

B. 多态约束（Polymorphic Constraints）

这是最强大的地方。如果你写了一个针对 AbstractCdmoSchedule 的约束（例如：每个员工每天工作不能超过 8 小时），它会自动应用到所有的子类（合成、包装）中。

你只需要写一次约束，所有遵循基类结构的业务模块都能受益。

C. Constraint Configuration 的集成

在 CDMO 中，不同车间的硬/软约束权重可能不同。你可以利用继承，在基类中定义基础约束权重，在子类中覆盖这些权重（利用 @ConstraintConfigurationProvider）。

4. 什么时候该用继承？

在 CDMO 系统开发中，如果你遇到以下情况，建议使用继承：

多租户/多工厂支持：A 工厂和 B 工厂的排程逻辑 80% 相同，但 20% 的设备属性不同。

长期 vs 短期排产：

短期：精确到分钟，考虑反应釜。

长期（产能预估）：精确到天，只考虑总工时。

这两者可以继承自同一个 BaseCapacitySchedule。

代码整洁度：如果你发现你的 @PlanningSolution 类变得巨大（几千行），通过继承可以将基础架构代码（ID、Score、日志）与业务数据解耦。

5. 避坑指南

实体类型兼容性：如果基类返回 List<? extends BaseTask>，确保你的约束逻辑（Constraint Provider）能够正确处理这些基类类型，或者通过 instanceof 分发逻辑。

Solver 配置：在 solverConfig.xml 中，你通常需要指定具体的 solutionClass。继承允许你通过配置文件的不同，复用大部分后端代码来跑不同的求解任务。

总结一句话：Inheritance（继承）让你的 CDMO 排程引擎从“针对一个反应釜的小程序”变成“覆盖全厂所有生产环节的通用平台架构”。

这份文档描述了 Timefold 算法的“动力源”：移动（Move）与邻域选择（Neighborhood Selection）。

如果把寻找最优排产方案比作在漆黑的山脉中寻找最高峰，那么：

Move（移动） 就是你每一步跨出的方式（向左走、向右跨、还是跳到对面的山头）。

Neighborhood（邻域） 就是你站在这里，一步之内能走到的所有位置集合。

Selection（选择） 就是你决定尝试哪些步子。

对于你的 CDMO 反应釜排产，这一章决定了求解器能否在有限时间内跳出“局部最优”，找到效率最高的方案。

1. 什么是 Move（移动）？

在 Timefold 中，Move 是对当前方案的一个微小改动。

在你的场景下，常见的 Move 包括：

Change Move：把“阿司匹林批次”从反应釜 A 挪到反应釜 B。

Swap Move：把“阿司匹林批次”和“布洛芬批次”互换位置（互换釜，或者在同一个釜内互换顺序）。

List Variable Move（针对你之前关注的 List Variable）：

List Change Move：从反应釜 A 的任务列表中取出一个任务，插入到反应釜 B 的列表中的某个位置。

List Swap Move：交换两个任务在列表中的位置。

2. 什么是 Neighborhood（邻域）？

邻域是从当前状态通过一次 Move 能够到达的所有新状态的集合。

小邻域：只允许微调（例如只改一个任务的时间）。优点是算得极快，缺点是容易陷入“局部最优”（就像被困在一个小土丘上，看不见远处的大山）。

大邻域：允许剧烈的变动（例如一次互换多个任务）。优点是有机会发现更好的方案，缺点是搜索空间巨大，耗时长。

3. MoveSelector（移动选择器）：配置你的“步法”

这是文档中技术含量最高的部分。你可以告诉 Solver 尝试哪些动作：

A. 通用移动（Generic MoveSelectors）

Timefold 会自动根据你的模型生成这些移动。

如果你用了 List<BatchJob> batchList，Solver 会自动启用 ListChangeMove 和 ListSwapMove。

这是最省心的做法，通常能解决 90% 的问题。

B. 组合移动（Union Move Selector）

你可以配置多种移动的比例。例如：

70% 的频率尝试 ListChangeMove（换釜）。

30% 的频率尝试 ListSwapMove（换顺序）。

CDMO 应用：如果减少清洗成本（顺序相关）比平衡负载（釜相关）更重要，你可以调高 Swap 的比例。

4. 选择策略（Selection Order）

这是决定“先试哪一步”的策略：

Random（随机）：最常用。Solver 随机挑一个动作试一下，好就留下，不好就撤销。这能保证搜索的广度。

Exhaustive（穷举）：尝试所有可能的移动。这只适用于极小规模的问题。

Shuffled（洗牌后顺序遍历）：保证每一轮把所有步子都试一遍，但顺序随机。

5. 过滤与排序 (Filtering & Sorting) —— 核心优化手段

这是让你的 Solver 变聪明的关键：

Filtering (过滤)：

场景：如果“反应釜 A”不能做“酸性药物”，那么所有“把酸性药物移到釜 A”的 Move 都是废动作。

做法：通过 SelectionFilter 拦截这些无效 Move，Solver 就不会浪费 CPU 去计算这些注定失败的方案。

Sorting (排序)：

场景：优先尝试把“优先级最高”或“延期最久”的任务往前排。

做法：给 Move 打分，让 Solver 优先尝试那些看起来更有前途的改动。

6. 为什么这对 CDMO 很重要？

在制药排产中，约束非常“硬”且“杂”。

避免盲目搜索：如果你有 50 个反应釜和 500 个批次，可能的组合数超过宇宙原子总数。通过配置合理的 MoveSelector 和 Filter，你可以让 Solver 只在“有意义”的范围内跳跃。

解决“链式反应”：在 CDMO 中，一个反应釜的任务顺序一变，后面所有任务的开始时间都要跟着变。List Variable 配合高效的 ListMoveSelector 能自动处理这种复杂的连锁反应。

平衡“深度”与“广度”：

广度：通过随机移动尝试不同的设备分配。

深度：通过微调顺序减少清洗时间。

总结建议

初学者：保持默认配置。Timefold 会自动识别你的 @PlanningListVariable 并配置最合适的 List 移动。

进阶者：如果你发现 Solver 很难降低“清洗成本”，可以尝试手动配置 unionMoveSelector，增加 ListSwapMove 的权重。

专家级：编写自定义 SelectionFilter，直接从源头上切掉那些违反 GMP 基本规则（如材质不兼容）的移动，这能让你的求解效率提升数倍。

这一页文档本质上是在教你：不要让求解器漫无目的地乱撞，要给它一套高效的搜索策略。




优化--------------
这份文档介绍的是 Timefold 的 “构建启发式算法”（Construction Heuristics，简称 CH）。

如果把排产比作“把大象装进冰箱”，那么：

构建启发式 (CH)：就是如何从零开始，把所有的大象（生产任务）一个接一个地塞进冰箱（反应釜）里，直到所有的空格都被填满。

局部搜索 (LS)：是等所有大象都进去后，再调整它们的位置让空间更省。

在 Timefold 中，你必须先经过 CH 阶段生成一个“初稿”，然后才能进入优化阶段。

1. 核心工作原理：贪心算法 (Greedy)

CH 算法的特点是：只进不退。

它从所有任务都是 null（未排产）的状态开始。

每次挑选一个任务（Entity）。

遍历这个任务所有可能的选择（反应釜、时间点）。

选择当前看起来得分最高的那个选择。

确定后就不再更改，接着排下一个任务，直到所有任务排完。

2. 为什么 CH 如此重要？

速度极快：它不回溯，不纠结。对于 1000 个任务，它可能只需几百毫秒就能给出一个完整的排班表。

解决“未初始化”问题：Timefold 的复杂算法（如 Tabu Search）要求所有变量必须先有值。CH 就是那个“破冰者”。

3. 常见的 CH 算法类型

文档提到了几种策略，在 CDMO 场景下各有优劣：

A. First Fit (最快实现)

逻辑：拿到一个任务，把它放进第一个不违反硬约束的格子里。

评价：最简单，但效果一般。

B. First Fit Decreasing (FFD - 强烈推荐)

逻辑：先对任务进行排序（例如：按反应时间长短、体积大小从大到小排序），然后再一个一个放。

CDMO 应用：先把“大批量、长周期”的硬骨头任务排了，剩下的小任务再去塞缝隙。这通常比随机顺序好得多。

C. Cheapest Insertion (最省成本插入)

逻辑：专门用于 List Variable（你之前关注的）。它会计算把一个任务插入到当前反应釜队列的哪个位置（开头、中间、末尾）导致的得分下降最少。

CDMO 应用：它会自动帮你找到清洗切换成本最低的那个位置插进去。

4. 关键配置项

在 XML 或代码中，你可以配置如何进行“第一轮”排产：

code
Xml
download
content_copy
expand_less
<constructionHeuristic>
  <!-- 任务选择器：决定先排哪个任务 -->
  <constructionHeuristicType>FIRST_FIT_DECREASING</constructionHeuristicType>
  <!-- 你可以定义排序规则，比如按优先级排序 -->
  <entitySorterManner>DECREASING_DIFFICULTY_IF_AVAILABLE</entitySorterManner>
</constructionHeuristic>
5. 针对 CDMO 的实战建议
① 必须配置难度排序 (Difficulty Comparison)

在制药行业，有些任务非常“难”排（例如：需要特定材质的反应釜，且反应时间超长）。

建议：在你的 BatchJob 实体上实现难度比较逻辑。

理由：让 Solver 先处理难搞的任务。如果先排简单的任务，到最后难排的任务可能根本找不到可用的反应釜，导致 Hard Score 炸掉。

② 不要在这里浪费太多时间

CH 的目标是**“填满”而不是“完美”**。

有些用户试图在 CH 阶段就写非常复杂的逻辑，其实没必要。

只要 CH 能给出一个“合法的（无硬约束冲突）”初稿，剩下的交给后面的 Local Search (局部搜索) 去优化即可。

③ 观察“初始化分数”

如果你运行 Solver，日志里会显示 Construction Heuristic phase (...) ended.

如果这时分数里的 Hard Score 还是负数，说明你的任务太拥挤，或者 CH 策略太笨，导致连一个合法的初稿都凑不出来。这时你需要调整任务的排序逻辑。

总结

这页文档告诉你的核心点是：万事开头难。

Timefold 运行分为两个阶段：

阶段一 (CH)：用“贪心算法”快速把坑占满，产生一个完整但不一定好的方案。

阶段二 (LS)：在刚才的基础上，通过不断“交换、移动”来持续提升方案质量。

对于 CDMO 排产，推荐使用 FIRST_FIT_DECREASING 配合自定义的任务难度排序，这是开启高效优化大门的钥匙。
